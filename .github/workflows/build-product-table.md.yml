name: Build product table (Markdown)

on:
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate product_table.md
        shell: bash
        run: |
          python3 - <<'PY'
          import os, re, csv, urllib.parse, subprocess

          # что считаем картинками
          exts = {'.png', '.jpg', '.jpeg', '.webp', '.gif', '.svg'}

          # база Pages
          owner, repo = os.environ['GITHUB_REPOSITORY'].split('/')
          base_pages = f"https://{owner.lower()}.github.io/{repo.lower()}"

          # ===== опциональные словари названий =====
          def load_map(fname):
            d = {}
            if os.path.exists(fname):
              with open(fname, 'r', encoding='utf-8') as f:
                rdr = csv.reader(f)
                _ = next(rdr, None)
                for row in rdr:
                  if not row or len(row) < 2: continue
                  k = (row[0] or '').strip()
                  v = (row[1] or '').strip()
                  if k: d[k] = v
            return d
          products_map = load_map('products_map.csv')
          colors_map   = load_map('colors_map.csv')

          # ===== нормализация/парсинг имён =====
          translit = {'а':'a','б':'b','в':'v','г':'g','д':'d','е':'e','ё':'e','ж':'zh','з':'z','и':'i','й':'y',
                      'к':'k','л':'l','м':'m','н':'n','о':'o','п':'p','р':'r','с':'s','т':'t','у':'u','ф':'f',
                      'х':'kh','ц':'ts','ч':'ch','ш':'sh','щ':'shch','ъ':'','ы':'y','ь':'','э':'e','ю':'yu','я':'ya'}
          def norm_slug(s:str)->str:
            s = s.lower()
            s = ''.join(translit.get(ch, ch) for ch in s)
            s = re.sub(r'[^a-z0-9._-]+','_',s)
            s = re.sub(r'_+','_',s).strip('_')
            return s

          vol_token = re.compile(r'^\d+(?:[.,]\d+)?$')
          def norm_volume(tok):
            t = tok.replace(',', '.')
            if t == '22': t = '2.2'
            if re.fullmatch(r'0\d{2}', t): t = '0.' + t[1:]  # 075 -> 0.75
            return t

          # product_code_color_code_volume
          def parse_pack_filename(name_noext):
            toks = [t for t in name_noext.split('_') if t]
            volume = ''; color=''; product_tokens = toks[:]
            vol_i = None
            for i,t in enumerate(toks):
              if vol_token.fullmatch(t):
                vol_i = i; volume = norm_volume(t); break
            if vol_i is None:
              if toks: color = norm_slug(toks[-1]); product_tokens = toks[:-1]
            else:
              if vol_i < len(toks)-1:
                color = norm_slug(toks[-1]); product_tokens = toks[:vol_i]
              else:
                if vol_i >= 1: color = norm_slug(toks[vol_i-1]); product_tokens = toks[:vol_i-1]
                else: product_tokens=[]
            product = norm_slug('_'.join(product_tokens))
            return product, color, volume

          # object_N_<hint>_<color>.*  -> для задачи цвет игнорируем, берём "канонический" URL на hint
          def parse_object_filename(base_noext):
            b = norm_slug(base_noext)
            if not (b.startswith('object_1_') or b.startswith('object_2_')): return None
            parts = b.split('_', 2)
            if len(parts) < 3: return None
            n = parts[1]          # '1' или '2'
            rest = parts[2]
            # hint может содержать '_', цвет — последний токен (но мы его игнорируем)
            if '_' in rest:
              hint, _color = rest.rsplit('_', 1)
            else:
              hint = rest
            hint = norm_slug(hint)
            return n, hint

          # ===== индексируем банки (packshots) =====
          packs = {}  # (product,color) -> {vol: url}
          for root, _, files in os.walk('.'):
            if root.startswith('./.git') or root.startswith('./.github'): continue
            for f in files:
              ext = os.path.splitext(f)[1].lower()
              if ext not in exts: continue
              name_noext = os.path.splitext(f)[0]
              if name_noext.lower().startswith('object_'): continue  # банки только
              rel = os.path.relpath(os.path.join(root, f), '.').replace(os.sep, '/')
              url = base_pages + '/' + urllib.parse.quote(rel, safe="/._-~")
              product, color, volume = parse_pack_filename(name_noext)
              if not product or not color or not volume: continue
              d = packs.setdefault((product, color), {})
              d[volume] = url

          # ===== индексируем объекты и берём "канон" по hint =====
          # выбираем детерминированно — первый по алфавиту путь для каждого hint
          obj1_by_hint = {}  # hint -> url
          obj2_by_hint = {}  # hint -> url
          temp1, temp2 = {}, {}
          for root, _, files in os.walk('.'):
            if root.startswith('./.git') or root.startswith('./.github'): continue
            for f in files:
              ext = os.path.splitext(f)[1].lower()
              if ext not in exts: continue
              name_noext = os.path.splitext(f)[0]
              parsed = parse_object_filename(name_noext)
              if not parsed: continue
              n, hint = parsed
              rel = os.path.relpath(os.path.join(root, f), '.').replace(os.sep, '/')
              url = base_pages + '/' + urllib.parse.quote(rel, safe="/._-~")
              if n == '1':
                temp1.setdefault(hint, []).append(url)
              else:
                temp2.setdefault(hint, []).append(url)
          for hint, urls in temp1.items():
            obj1_by_hint[hint] = sorted(urls)[0]
          for hint, urls in temp2.items():
            obj2_by_hint[hint] = sorted(urls)[0]

          # поиск лучшего hint: самое длинное вхождение в product_code
          def find_by_hint(dct, product_code):
            best_url = ''
            best_len = 0
            for hint, url in dct.items():
              if hint in product_code and len(hint) > best_len:
                best_len = len(hint); best_url = url
            return best_url

          # ===== собираем строки =====
          def md_escape(s: str) -> str:
            return (s or '').replace('|', '\\|')

          rows = []
          keys = sorted(packs.keys(), key=lambda k:(k[0],k[1]))  # только те, где есть банки
          for product, color in keys:
            pmap = packs[(product,color)]
            pack_075 = pmap.get('0.75','')
            if not pack_075:
              for v,u in pmap.items():
                if v.startswith('0.75'): pack_075=u; break
            pack_22 = pmap.get('2.2','')
            if not pack_22:
              for v,u in pmap.items():
                if v.startswith('2.2'): pack_22=u; break

            product_name = products_map.get(product, product.replace('_',' ').title())
            color_name   = colors_map.get(color, color)

            # теперь объектные фото — ТОЛЬКО по hint (цвет не учитываем)
            o1 = find_by_hint(obj1_by_hint, product) or ''
            o2 = find_by_hint(obj2_by_hint, product) or ''

            rows.append({
              'product_code': product,
              'product_name': product_name,
              'color_code': color,
              'color_name': color_name,
              'pack_0_75': pack_075,
              'pack_2_2': pack_22,
              'object_1': o1,
              'object_2': o2,
              'video': ''
            })

          # ===== Markdown =====
          header = ["product_code","product_name","color_code","color_name","pack_0_75","pack_2_2","object_1","object_2","video"]
          out = []
          out.append("| " + " | ".join(header) + " |")
          out.append("|" + "|".join("-"* (len(h)+2) for h in header) + "|")
          for r in rows:
            out.append("| " + " | ".join([
              md_escape(r['product_code']),
              md_escape(r['product_name']),
              md_escape(r['color_code']),
              md_escape(r['color_name']),
              r['pack_0_75'],
              r['pack_2_2'],
              r['object_1'],
              r['object_2'],
              r['video']
            ]) + " |")

          with open('product_table.md','w',encoding='utf-8') as fw:
            fw.write("\n".join(out) + "\n")

          subprocess.check_call(['git','config','user.name','github-actions'])
          subprocess.check_call(['git','config','user.email','github-actions@github.com'])
          subprocess.check_call(['git','add','product_table.md'])
          subprocess.check_call(['git','commit','-m','data: product_table.md with object_1/object_2 by product hint (color-agnostic)'])
          PY

      - name: Push changes
        run: git push || true
